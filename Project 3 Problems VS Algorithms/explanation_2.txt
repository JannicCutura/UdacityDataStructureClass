My idea was to build on the binary search algorithm. The problem is very similar:
If not for the rotation point, it would just be a binary search. Now with the rotation
point we need to keep this in mind. The way I do it is:
- Check whether rotation point is left or right of the middle. You can easily do this
  by checking start and end points of both sublist. one start will be smaller than the end
- If the target number is in the "sorted" part, simply do recursive binary search
- if the target number is in the unsorted part, repeat from above on the unsorted
  part only.


Time complexity is O(log(n)), where n is the number of integers in the list. I am essentially
running a binary search algorithm with a little twist.

Space complexity is also O(log(n)) since we need to store the return values for each
iteration. 


Note: I do not really like my code. I started to build it from scratch and modified
until it worked, but clearly it is not a very readable solution. I would appreciate 
some feedback.